Алгоритмы сортировки и поиска

1. Сортировка выбором (Selection Sort) — это простой алгоритм, который последовательно делит массив на две части: отсортированную и неотсортированную. 

Описание: на каждом шаге алгоритм находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части, тем самым перемещая его в конец отсортированной секции. 

Пошаговая работа:
Сначала выводится исходный массив.
Затем выполняется сортировка методом выбора, после которой снова выводится массив, теперь уже отсортированный.
Используются вспомогательные функции (swap и printArray) для удобства чтения и понимания кода.

Временная сложность: сложность алгоритма составляет O(n²) даже в лучшем случае. Анализ сложности: алгоритм всегда выполняет ≈ n²/2 сравнений и n обменов. 
Внешний цикл выполняется n-1 раз, внутренний цикл выполняется (n-i) раз для каждого i, что дает общее количество сравнений: Σ(n-i) = n(n-1)/2 ≈ O(n²).

Пример:
Исходный массив: [64 25 12 22 11]
Отсортированный массив: [11 12 22 25 64]

2. Сортировка обменом (пузырьком) (Bubble Sort) — это простой алгоритм сортировки, который последовательно сравнивает соседние элементы массива и меняет их местами, если они стоят в неправильном порядке.

Описание: алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. 
Процесс повторяется до тех пор, пока список полностью не отсортируется.

Пошаговая работа:
Внешний цикл проходит по каждому элементу списка.
Внутренний цикл сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке.
Если за один проход не было выполнено ни одной перестановки, это означает, что список уже отсортирован, и алгоритм завершает работу.

Временная сложность: Временная сложность алгоритма сортировки пузырьком — O(n²). В худшем случае требуется n-1 проходов, на i-м проходе выполняется n-i сравнений. 
Общее количество сравнений: Σ(n-i) = n(n-1)/2 ≈ O(n²). С оптимизацией (флаг обменов) лучший случай становится O(n).

Пример: 
Исходный массив [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив [11, 12, 22, 25, 34, 64, 90]

3. Сортировка вставками (Insertion Sort) — это простой алгоритм, который строит отсортированный массив, постепенно расширяя его.

Описание: алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, 
сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Пошаговая работа:
Алгоритм проходит через массив, начиная со второго элемента. 
Для каждого элемента он находит правильное место в уже отсортированной части массива и вставляет его туда.

Временная сложность: В худшем случае каждый новый элемент требует сдвига всех элементов отсортированной части. Количество сравнений и сдвигов: Σi = n(n-1)/2 ≈ O(n²). В лучшем случае требуется только n-1 сравнений.

Пример:
Исходный массив [12, 11, 13, 5, 6]
Отсортированный массив [5, 6, 11, 12, 13]

4. Алгоритм сортировки слиянием (Merge Sort) — это эффективный алгоритм сортировки, рекурсивный алгоритм, работающий по принципу «разделяй и властвуй». 

Описание: Он рекурсивно делит массив на две половины, сортирует каждую половину отдельно, а затем объединяет отсортированные половины в один отсортированный массив.

Пошаговая работа:
Массив рекурсивно делится на две половины до тех пор, пока каждая половина не станет содержать один элемент.
Затем отсортированные половины объединяются в один отсортированный массив.

Временная сложность: O(n log n) — где n — количество элементов в массиве. Время работы описывается рекуррентным соотношением T(n) = 2T(n/2) + O(n). Алгоритм требует дополнительной памяти для слияния.

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

5. Алгоритм сортировки Шелла (Shellsort) — это обобщение алгоритма сортировки вставками, который сортирует элементы, находящиеся на определённом расстоянии друг от друга. 

Описание: сначала сравнивает и сортирует элементы, расположенные на некотором расстоянии друг от друга (грубые проходы), а затем постепенно уменьшает это расстояние. 
Итоговый проход выполняется с расстоянием, равным (1), что превращает алгоритм в обычную сортировку вставками для почти отсортированного массива. 

Пошаговая работа:
Выбор шага: изначально шаг равен половине длины массива, затем постепенно уменьшается.
Сортировка вставками: на каждом шаге выполняется сортировка вставками для элементов, находящихся на расстоянии шага.
Уменьшение шага: Шаг уменьшается до тех пор, пока не станет равным 1, после чего выполняется обычная сортировка вставками.

Временная ложность: O(n^{3/2}) — в среднем. Сложность сильно зависит от выбора последовательности шагов. Для последовательности Кнута сложность O(n^(3/2)), для последовательности Седжвика O(n^(4/3)). 

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

6. Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых
алгоритмов сортировки. Это эффективный алгоритм сортировки, который работает по принципу «разделяй и властвуй».

Описание: Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие),
и в сортировке полученных частей рекурсивным вызовом себя от них.

Пошаговая работа:
Алгоритм быстрой сортировки (Quick Sort) работает по принципу "разделяй и властвуй". Он выбирает опорный элемент, разделяет массив на две части (элементы меньше опорного и элементы больше опорного), 
а затем рекурсивно сортирует обе части.

Временная сложность: Средняя временная сложность: O(n log n). В среднем случае время работы описывается как T(n) = 2T(n/2) + O(n) = O(n log n). 
В худшем случае (уже отсортированный массив) T(n) = T(n-1) + O(n) = O(n²).

Пример:
Исходный массив: [10 7 8 9 1 5]
Отсортированный массив: [1 5 7 8 9 10]

7. Пирамидальная сортировка — это алгоритм сортировки, основанный на использовании структуры данных «куча» (heap). 

Описание: основная идея заключается в том, чтобы сначала построить из массива двоичную кучу (обычно max-heap), а затем последовательно извлекать максимальный элемент и помещать его в конец массива,
уменьшая размер кучи на единицу.

Пошаговая работа:
heapify: функция, которая поддерживает свойство кучи (max-heap), перемещая наибольший элемент вверх.
heapsort: сначала строит max-heap из массива, затем последовательно извлекает максимальный элемент и помещает его в конец массива, уменьшая размер кучи.

Временная сложность:
Средняя и худшая сложность: O(n \log n). Построение кучи занимает O(n) времени. Каждое из n извлечений максимума требует O(log n) времени для перестройки кучи. Итого: O(n) + n × O(log n) = O(n log n).

Пример:
Исходный массив: [12, 11, 13, 5, 6, 7]
Отсортированный массив: [5, 6, 7, 11, 12, 13]

8. Последовательный поиск — это простой алгоритм, который последовательно перебирает элементы списка, сравнивая их с искомым значением. 

Описание: это алгоритм, который ищет заданный элемент, последовательно проверяя каждый элемент коллекции (например, массива) с начала до конца. 
Этот метод является простейшим и не требует предварительной сортировки данных.

Пошаговая работа:
Функция linear_search принимает два аргумента: список arr и искомое значение target.
Алгоритм последовательно перебирает элементы списка, проверяя, совпадает ли текущий элемент с искомым значением.
Если совпадение найдено, возвращается индекс элемента.
Если элемент не найден после полного перебора, возвращается -1.

Временная сложность последовательного поиска составляет O(n), где (n) — количество элементов в массиве. Это означает, что в худшем случае алгоритму придется проверить все элементы, 
чтобы найти искомое значение или убедиться в его отсутствии. 

Пример:
Исходный массив: [4, 2, 7, 1, 9]
Результат: Элемент 7 найден на позиции 2

9.Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом,
что искомый элемент попадает в одну из этих частей. 

Описание: поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. 
Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.

Пошаговая работа:
Массив заранее сортируется (уже отсортирован). Каждый раз проверяется средний элемент массива. Если целевой элемент равен среднему, выводится индекс.
Если цель меньше среднего значения, дальнейший поиск осуществляется в левой части массива. Если цель больше среднего значения, поиск продолжается в правой части. 
Процесс повторяется пока не найдем элемент или не выясним, что его нет.

Временная сложность: O(log n) потому что на каждой итерации массив делится ровно наполовину, сокращая область поиска вдвое. 
Число итераций пропорционально количеству двоичных делений размера массива, что выражается логарифмом по основанию 2 от числа элементов.

Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент найден на позиции 5


10. Интерполирующий поиск — это алгоритм поиска, который улучшает бинарный поиск за счет более умной оценки позиции искомого элемента, используя его значение относительно диапазона данных.

Описание: Интерполирующий поиск похож на бинарный, но вычисляет следующую позицию поиска не просто посредине, а исходя из предположения о равномерном распределении значений. 
Эта стратегия позволяет быстрее находить элементы в больших равномерно распределённых наборах данных.

Пошаговая работа: Массив должен быть предварительно отсортированным. Алгоритм пытается оценить положение искомого элемента путём расчёта приблизительной позиции, учитывая распределение элементов.
После оценки выполняется проверка среднего элемента. Если искомое значение меньше оценённого, рассматривается нижняя половина массива, иначе верхняя. 
Повторяется до тех пор, пока не найдётся элемент или станет понятно, что его нет.

Временная сложность: Временная сложность интерполяционного поиска составляет (O(log (log (n)))) в среднем случае при равномерном распределении данных, что лучше, чем у бинарного поиска ((O(log (n)))). 
Однако в худшем случае (при неравномерном распределении) сложность может достигать O(n), как у линейного поиска. 

Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент найден на позиции 5


11. Поиск по Фибоначчи

Поиск по Фибоначчи — это метод быстрого поиска элемента в отсортированном списке или метод нахождения экстремума функции в заданном интервале, использующий числа Фибоначчи для деления массива или интервала на части.

Описание: Поиск по Фибоначчи представляет собой модификацию бинарного поиска, где массив делится не пополам, а на основании чисел Фибоначчи. 
Основная идея заключается в выборе точки разделения таким образом, чтобы длина оставшихся частей соответствовала двум ближайшим числам Фибоначчи.

Пошаговая работа: Сначала генерируются числа Фибоначчи, начиная с небольших значений, и выбирается первое число, превышающее длину массива. 
Затем выполняется сравнение элемента в выбранной точке массива с искомым элементом.
Исходя из результата сравнения, сдвигаются границы поиска и повторно применяется логика Фибоначчи для выбора новой точки разделения. 
Процесс продолжается до тех пор, пока не найдётся элемент или не станет ясно, что его нет в массиве.

Временная сложность: временная сложность вычислений Фибоначчи зависит от алгоритма: наивная рекурсивная реализация имеет экспоненциальную сложность (O(2^{n})) из-за многократного пересчета значений, 
тогда как итеративный подход или использование мемоизации (динамическое программирование) значительно снижают её до линейной (O(n)). 
Поиск Фибоначчи (как алгоритм поиска) имеет временную сложность (O(log n)), а для конкретной задачи — (O(n)) в худшем случае. 

Пример:
Исходный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Результат выполнения: Элемент найден на позиции: 8
