Алгоритмы сортировки и поиска

1. Сортировка выбором (Selection Sort) — это простой алгоритм, который последовательно делит массив на две части: отсортированную и неотсортированную. 

Описание: на каждом шаге алгоритм находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части, тем самым перемещая его в конец отсортированной секции. 

Пошаговая работа:
1.Сначала выводится исходный массив. Здесь подключается библиотека ввода-вывода iostream, позволяющая выводить и вводить данные через стандартный поток (cin и cout), а также объявляется использование пространства имен стандартной библиотеки (std::) для упрощения записи операторов.
2.Затем выполняется сортировка методом выбора, после которой снова выводится массив, теперь уже отсортированный. Эта функция принимает два аргумента типа int по ссылке (&). Это позволяет менять значение переменных вне самой функции. Внутри функции создается временная переменная temp, куда временно сохраняется значение первого элемента, после чего оба элемента меняются местами.
3.Основная функция сортировки выбором (selectionSort):
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) { // Внешний цикл проходит по каждой позиции массива
        int minIndex = i;               // Предполагаемый минимальный индекс начинается с текущего индекса цикла
        ...
Здесь реализован метод сортировки выбором. Основной принцип метода заключается в поиске наименьшего элемента среди оставшихся неотсортированных элементов и замене его с первым несортированным элементом. Этот процесс повторяется для каждого элемента массива.

Временная сложность: сложность алгоритма составляет O(n²) даже в лучшем случае. Анализ сложности: алгоритм всегда выполняет ≈ n²/2 сравнений и n обменов. 
Внешний цикл выполняется n-1 раз, внутренний цикл выполняется (n-i) раз для каждого i, что дает общее количество сравнений: Σ(n-i) = n(n-1)/2 ≈ O(n²).

Пример:
Исходный массив: [64 25 12 22 11]
Отсортированный массив: [11 12 22 25 64]

2. Сортировка обменом (пузырьком) (Bubble Sort) — это простой алгоритм сортировки, который последовательно сравнивает соседние элементы массива и меняет их местами, если они стоят в неправильном порядке.

Описание: алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. 
Процесс повторяется до тех пор, пока список полностью не отсортируется.

Пошаговая работа:
1.Определение функции bubble_sort. Функция получает аргумент arr — список целых чисел, подлежащий сортировке. Переменная n хранит длину списка с помощью встроенной функции len(). Затем запускается внешний цикл, выполняющийся столько же раз, сколько элементов в списке. 
2.Флаг swapped. Этот булевский флаг нужен для оптимизации процесса сортировки. Изначально он установлен в False, и если за весь внутренний цикл не произойдет ни одной замены, значит, массив уже отсортирован, и дальнейшее выполнение внешнего цикла не имеет смысла.
3.Внутренний цикл сравнения соседних элементов. Во внутреннем цикле осуществляется сравнение соседних элементов (arr[j] и arr[j+1]). Если текущий элемент больше последующего, они меняются местами благодаря множественному присваиванию Python (arr[j], arr[j+1] = arr[j+1], arr[j]).
4.Проверка флага swapped. Если в течение всего прохождения внутреннего цикла не произошло ни одной перестановки (флаг остался равен False), то выход из внешнего цикла гарантирует завершение работы алгоритма раньше срока, так как дальнейшая сортировка бессмысленна.
5.Возврат отсортированного массива:
return arr
По завершении работы внешнего цикла возвращается отсортированный массив.
Пример использования функции:

arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("Отсортированный массив:", sorted_arr)
Создается массив чисел [64, 34, 25, 12, 22, 11, 90], затем он передается в функцию bubble_sort, после чего результат выводится на экран функцией print().

Временная сложность: Временная сложность алгоритма сортировки пузырьком — O(n²). 

В худшем случае требуется n-1 проходов, на i-м проходе выполняется n-i сравнений. 
Общее количество сравнений: Σ(n-i) = n(n-1)/2 ≈ O(n²). С оптимизацией (флаг обменов) лучший случай становится O(n).

Пример: 
Исходный массив [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив [11, 12, 22, 25, 34, 64, 90]

3. Сортировка вставками (Insertion Sort) — это простой алгоритм, который строит отсортированный массив, постепенно расширяя его.

Описание: алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, 
сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Пошаговая работа: 
1.Определение функции insertion_sort:
Функция принимает аргумент arr — массив целых чисел. Цикл for перебирает элементы массива, начиная со второго элемента (range(1, len(arr))), так как первый элемент изначально считается отсортированным.
2.Перемещение элементов вправо для освобождения места новому элементу:
Внутри цикла while проверяется условие: если текущий элемент (key) меньше любого предыдущего элемента, то предыдущие элементы сдвигаются вправо, освобождая место для нового элемента. Переменная j постепенно уменьшается, двигаясь назад по списку, пока не найдет подходящее место для вставки ключа.
3.Вставка элемента в правильную позицию:
arr[j + 1] = key                     # Ключ помещается в свою позицию
После завершения цикла while элемент key размещается в правильной позиции внутри отсортированной части массива.
4.Возвращение отсортированного массива:
return arr                           # Возвращение отсортированного массива
После окончания работы основного цикла функция возвращает полностью отсортированный массив.

Временная сложность: В худшем случае каждый новый элемент требует сдвига всех элементов отсортированной части. Количество сравнений и сдвигов: Σi = n(n-1)/2 ≈ O(n²). В лучшем случае требуется только n-1 сравнений.

Пример:
Исходный массив [12, 11, 13, 5, 6]
Отсортированный массив [5, 6, 11, 12, 13]

4. Алгоритм сортировки слиянием (Merge Sort) — это эффективный алгоритм сортировки, рекурсивный алгоритм, работающий по принципу «разделяй и властвуй». 

Описание: Он рекурсивно делит массив на две половины, сортирует каждую половину отдельно, а затем объединяет отсортированные половины в один отсортированный массив.

Пошаговая работа:
1.Разбиение массива на подмассивы:
mergeSort(array, 0, array.length - 1);
Главная функция вызывает процедуру mergeSort, передавая ей исходный массив, левый и правый индексы (границы диапазона сортировки). Рекурсия продолжает деление массива пополам до тех пор, пока длина массива не сократится до одного элемента.
2.Рекурсивное разделение массива:
Метод mergeSort разделяет массив на две примерно равные части, вычисляя середину (middle). Далее он рекурсивно вызывает себя для левой и правой частей массива, после чего объединяет обе отсортированные части обратно в единый массив посредством процедуры merge.
3.Процедура объединения отсортированных подмассивов (merge):Функция merge отвечает за объединение отсортированных подмассивов. Массив сначала делится на левую и правую половину, которые копируются в отдельные временные массивы (leftArray и rightArray). Затем элементы обоих временных массивов сливаются обратно в основной массив путем последовательного сравнения и добавления меньших элементов. Остаточные элементы, если они остались, также добавляются в общий массив.
4.Итоговый вывод результата:
После завершения сортировки результат выводится на консоль оператором System.out.println(), использующим цикл for-each для обхода массива.

Временная сложность: O(n log n) — где n — количество элементов в массиве.

Время работы описывается рекуррентным соотношением T(n) = 2T(n/2) + O(n). Алгоритм требует дополнительной памяти для слияния.

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

5. Алгоритм сортировки Шелла (Shellsort) — это обобщение алгоритма сортировки вставками, который сортирует элементы, находящиеся на определённом расстоянии друг от друга. 

Описание: сначала сравнивает и сортирует элементы, расположенные на некотором расстоянии друг от друга (грубые проходы), а затем постепенно уменьшает это расстояние. 
Итоговый проход выполняется с расстоянием, равным (1), что превращает алгоритм в обычную сортировку вставками для почти отсортированного массива. 

Пошаговая работа:
1.Инициализация начальных условий:
public static void shellSort(int[] array) {
    int n = array.length; // Получаем длину массива
    int gap = n / 2;      // Устанавливаем начальный шаг (промежуток)
Алгоритм начинается с задания начального промежутка («шага»), равного половине длины массива. Эта величина далее постепенно уменьшается, обеспечивая постепенное улучшение порядка элементов.
2.Основной цикл сортировки:
Главный цикл включает два вложенных уровня:
Внешний цикл (while (gap > 0)) управляет изменением шага, сокращая его вдвое на каждой итерации.
Внутренний цикл (for (int i = gap; i < n; i++)) реализует основную идею сортировки вставками, но применяется не ко всему массиву сразу, а к отдельным подгруппам, разделённым расстоянием, равным текущему шагу (gap).
3.Детали внутренней сортировки: Каждый элемент проверяется относительно предыдущих элементов, расположенных на расстоянии шага (gap). Если предыдущий элемент больше текущего, он смещается вперёд, создавая пространство для вставки текущего элемента.
4.Завершение работы и уменьшение шага:
gap /= 2;                       // Уменьшаем шаг
Шаг постепенно уменьшается до единицы, пока окончательно не завершится обычный порядок сортировки вставками.
5.Использование в основном классе: После сортировки полученный результат выводится на экран стандартным способом с использованием оператора System.out.println() и цикла for-each.

Временная ложность: O(n^{3/2}) — в среднем. 

Сложность сильно зависит от выбора последовательности шагов. Для последовательности Кнута сложность O(n^(3/2)), для последовательности Седжвика O(n^(4/3)). 

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

6. Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых
алгоритмов сортировки. Это эффективный алгоритм сортировки, который работает по принципу «разделяй и властвуй».

Описание: Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие),
и в сортировке полученных частей рекурсивным вызовом себя от них.

Пошаговая работа:
1. Инициализация вектора и вызов функции сортировки: Здесь создаётся вектор целого типа std::vector<int> и передаётся в функцию quickSort, которая принимает три параметра: сам массив, нижний индекс (low) и верхний индекс (high).
2. Функция разделения массива (partition):
Эта функция является ключевой частью алгоритма Quicksort. Она берёт диапазон массива и производит его разделение на две части вокруг выбранного опорного элемента (pivot). Все элементы, меньшие опорного, переносятся влево, а остальные остаются справа.
Опорный элемент (pivot): выбран как последний элемент в диапазоне (arr[high]).
Индекс i: обозначает границу между меньшей и большей частями массива.
Цикл for: просматривает массив и при необходимости меняет местами элементы, стоящие левее границ, с теми, что находятся правее.
3. Реализация быстрого сортирования (quickSort):
Алгоритм быстро разделяет массив на две части, основываясь на результате функции partition. Сначала выделяется опорный элемент (pi), после чего процедура рекурсивно вызывается отдельно для левой и правой частей массива. Важно отметить, что рекурсивные вызовы гарантируют, что каждая часть массива сортируется отдельно, что обеспечивает эффективность сортировки даже для крупных массивов.

Временная сложность: Средняя временная сложность: O(n log n).

В среднем случае время работы описывается как T(n) = 2T(n/2) + O(n) = O(n log n). 
В худшем случае (уже отсортированный массив) T(n) = T(n-1) + O(n) = O(n²).

Пример:
Исходный массив: [10 7 8 9 1 5]
Отсортированный массив: [1 5 7 8 9 10]

7. Пирамидальная сортировка — это алгоритм сортировки, основанный на использовании структуры данных «куча» (heap). 

Описание: основная идея заключается в том, чтобы сначала построить из массива двоичную кучу (обычно max-heap), а затем последовательно извлекать максимальный элемент и помещать его в конец массива,
уменьшая размер кучи на единицу.

Пошаговая работа:
1.Создание пирамиды (Max Heap): Функция heapify отвечает за поддержание структуры Max Heap, которая требует, чтобы каждый узел был больше или равен своим потомкам. Эта операция необходима для превращения обычного массива в пирамиду (куче), готовую к извлечению максимального элемента.
2.Преобразование массива в кучу (heap construction):
def heapsort(arr):
    n = len(arr)
    # Строим Max Heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
Для преобразования обычного массива в Max Heap используется цикл, который идёт от середины массива к началу. Почему именно от середины? Потому что нижняя половина дерева — это листья, которым не нужны потомки, и поэтому им не нужно поддерживать свойство кучи.
3. Процесс извлечения элементов из кучи:
После построения кучи следующий этап — собственно сортировка. Мы берем корень (самый большой элемент) и заменяем его с последним элементом массива, уменьшая таким образом размеры кучи. Затем восстанавливаем свойство Max Heap с помощью вызова heapify для уменьшенного массива.

Временная сложность:
Средняя и худшая сложность: O(n \log n). 

Построение кучи занимает O(n) времени. Каждое из n извлечений максимума требует O(log n) времени для перестройки кучи. Итого: O(n) + n × O(log n) = O(n log n).

Пример:
Исходный массив: [12, 11, 13, 5, 6, 7]
Отсортированный массив: [5, 6, 7, 11, 12, 13]

8. Последовательный поиск — это простой алгоритм, который последовательно перебирает элементы списка, сравнивая их с искомым значением. 

Описание: это алгоритм, который ищет заданный элемент, последовательно проверяя каждый элемент коллекции (например, массива) с начала до конца. 
Этот метод является простейшим и не требует предварительной сортировки данных.

Пошаговая работа:
1.Функция linear_search принимает два аргумента: список arr и искомое значение target.
2.Алгоритм последовательно перебирает элементы списка, проверяя, совпадает ли текущий элемент с искомым значением. Используется цикл for, который последовательно перебирает все элементы списка с помощью встроенного метода range(len(arr)). Длина списка определяется с помощью функции len().
Индексация: Доступ к элементам осуществляется через квадратные скобки (arr[i]), где i — текущий индекс.
Условие проверки: если текущий элемент совпадает с искомым (arr[i] == target), немедленно возвращается индекс этого элемента (return i).
3.Если совпадение найдено, возвращается индекс элемента.
Если элемент не найден после полного перебора, возвращается -1.

Временная сложность последовательного поиска составляет O(n).

Где (n) — количество элементов в массиве. Это означает, что в худшем случае алгоритму придется проверить все элементы, 
чтобы найти искомое значение или убедиться в его отсутствии. 

Пример:
Исходный массив: [4, 2, 7, 1, 9]
Результат: Элемент 7 найден на позиции 2

9.Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом,
что искомый элемент попадает в одну из этих частей. 

Описание: поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. 
Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.

Пошаговая работа:
1.Описание функции бинарного поиска (binarySearch):
int binarySearch(int arr[], int left, int right, int target) {
    while (left <= right) {
        int mid = left + (right - left) / 2; // Рассчитываем среднюю точку
Функция принимает четыре аргумента:
arr[]: отсортированный массив.
left: индекс начала текущего интервала поиска.
right: индекс конца текущего интервала поиска.
target: искомое значение.
Средняя точка (mid) рассчитывается как среднее арифметическое границ интервала (left и right), что обеспечивает равномерное сокращение области поиска.
2.Анализ средней точки:
if (arr[mid] == target) return mid; // Нашли элемент, возвращаем его индекс
else if (arr[mid] > target) right = mid - 1; // Искать слева
else left = mid + 1; // Искать справа
3.3. Обработка ситуации, когда элемент не найден:
return -1; // Элемент не найден
Если после завершения цикла не удалось обнаружить искомый элемент, функция возвращает специальный индикатор -1, показывая отсутствие нужного значения в массиве.

Временная сложность: O(log n) 

На каждой итерации массив делится ровно наполовину, сокращая область поиска вдвое. 
Число итераций пропорционально количеству двоичных делений размера массива, что выражается логарифмом по основанию 2 от числа элементов.

Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент найден на позиции 5


10. Интерполирующий поиск — это алгоритм поиска, который улучшает бинарный поиск за счет более умной оценки позиции искомого элемента, используя его значение относительно диапазона данных.

Описание: Интерполирующий поиск похож на бинарный, но вычисляет следующую позицию поиска не просто посредине, а исходя из предположения о равномерном распределении значений. 
Эта стратегия позволяет быстрее находить элементы в больших равномерно распределённых наборах данных.

Пошаговая работа: 
1.Массив должен быть предварительно отсортированным. 
Функция interpolationSearch принимает четыре аргумента:
arr[]: отсортированный массив,
left: индекс начала текущего участка массива,
right: индекс конца текущего участка массива,
target: искомое значение.
Главное отличие от простого бинарного поиска состоит в том, что здесь используется оценка вероятности расположения элемента с помощью формулы интерполяции.
2.Алгоритм пытается оценить положение искомого элемента путём расчёта приблизительной позиции, учитывая распределение элементов.
Формула интерполяционного поиска:
int pos = left + (((double)(right-left)/(arr[right]-arr[left]))*(target-arr[left]));
Рассчитывается ожидаемая позиция (pos), где может находиться искомый элемент. Формула учитывает разницу между крайними элементами и их позициями, что позволяет точнее предсказывать расположение элемента, особенно если данные распределены равномерно.
3.После оценки выполняется проверка среднего элемента.
if (arr[pos] == target) return pos; // Совпадение найдено
Если искомое значение меньше оценённого, рассматривается нижняя половина массива, иначе верхняя. Если найденное значение равно искомому, немедленно возвращается индекс элемента.
4.Изменение границ поиска:
if (arr[pos] < target) left = pos + 1; // Сдвиг влево
else right = pos - 1; // Сдвиг вправо
Если центральное значение меньше искомого, следующая итерация будет выполняться на правом подинтервале (left = pos + 1). Если оно больше, следующая итерация перейдёт на левый подинтервал (right = pos - 1).

Временная сложность: Временная сложность интерполяционного поиска составляет (O(log (log (n)))) 

(O(log (log (n)))) в среднем случае при равномерном распределении данных, что лучше, чем у бинарного поиска ((O(log (n)))). 
Однако в худшем случае (при неравномерном распределении) сложность может достигать O(n), как у линейного поиска.

Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент найден на позиции 5


11. Поиск по Фибоначчи

Поиск по Фибоначчи — это метод быстрого поиска элемента в отсортированном списке или метод нахождения экстремума функции в заданном интервале, использующий числа Фибоначчи для деления массива или интервала на части.

Описание: Поиск по Фибоначчи представляет собой модификацию бинарного поиска, где массив делится не пополам, а на основании чисел Фибоначчи. 
Основная идея заключается в выборе точки разделения таким образом, чтобы длина оставшихся частей соответствовала двум ближайшим числам Фибоначчи.

Пошаговая работа: 
1.Сначала генерируются числа Фибоначчи, начиная с небольших значений, и выбирается первое число, превышающее длину массива. 
fib_prev = 0  # F(k-2)
fib_curr = 1  # F(k-1)
fib_next = fib_prev + fib_curr  # F(k)
Здесь определяются первые два числа Фибоначчи: fib_prev и fib_curr, а третье число (fib_next) получается суммой первых двух. Эти числа будут использоваться для организации поиска.
2.Настройка начальной границы поиска:
length = len(arr)
while fib_next < length:
    fib_prev = fib_curr
    fib_curr = fib_next
    fib_next = fib_prev + fib_curr
Первый шаг — определение ближайшего числа Фибоначчи, большего или равного длине массива. Это делается для того, чтобы иметь достаточную ширину окна поиска, покрывающего всю длину массива
3.Сам поиск:
Основное тело поиска основано на следующем подходе:
Рассчитывается индекс (i), исходя из последнего известного числа Фибоначчи (fib_prev).
Если элемент на позиции i соответствует искомому (arr[i] == x), поиск прекращается, и возвращается индекс.
Если элемент меньше искомого (arr[i] < x), увеличиваем окно поиска (переносим фокус ближе к концу массива).
Если элемент больше искомого (arr[i] > x), уменьшаем окно поиска (оставляем в рассмотрении только начало массива).
4. Окончательное решение:
if fib_curr and arr[offset + 1] == x:
    return offset + 1
return -1
После завершения цикла возможен случай, когда элемент находится на границе массива, поэтому дополнительно проверяется элемент рядом с последней известной точкой (offset + 1). Если ничего не найдено, возвращается индекс -1.

Временная сложность:  (O(log n))

Временная сложность вычислений Фибоначчи зависит от алгоритма: наивная рекурсивная реализация имеет экспоненциальную сложность (O(2^{n})) из-за многократного пересчета значений, 
тогда как итеративный подход или использование мемоизации (динамическое программирование) значительно снижают её до линейной (O(n)). 
Поиск Фибоначчи (как алгоритм поиска) имеет временную сложность (O(log n)), а для конкретной задачи — (O(n)) в худшем случае. 

Пример:
Исходный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Результат выполнения: Элемент найден на позиции: 8
